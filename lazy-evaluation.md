# Ленивые вычисления (Отложенные вычисления)

Ленивые вычисления - это стратегия вычисления применяемая в некоторых языках программирования, согласно которой вычисления следует откладывать до тех пор, пока не понадобится их результат.
Используя данную стратегию, можно сократить общий объем вычислений за счет тех вычислений, результат которых не будет использоваться. К примеру в языке Haskell, ленивые вычисления используются по умолчанию.

### Пример ленивых вычислений в языке Haskell
```haskell
-- [1..] - Генерирует бесконечный список
-- take 5 - Берет из бесконечного списка, первые 5 элементов
-- Тоесть, бесконечный список полностью не генерируется, а генерируется только список из первый 5 элементов.
Prelude> take 5 [1..]
[1,2,3,4,5]
```

### Пример ленивых вычислений в языке Python
В языке Python ленивые вычисления реализованы с помощью функций-генераторов и ключевого слова `yield`.
```python
def infinite_list():
    x = 0 
    while True:
        x += 1
        yield x
		
def take(n, iter):
    return [next(iter) for i in range(n)]
		
>>> take(10, infinite_list())
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		
```

### Пример ленивых вычислений в языке Scheme (GNU Guile)
В языке программирования Scheme, ленивые вычисления реализуются с помощью `delay` и `force`.
`delay` берет блок кода и, вместо того чтобы выполнить, откладывает его и его параметры как `promise`. Когда к отложенному `promise` применяется `force` код будет выполнен и будет возвращено значение. Затем `promise` сохраняет результат, так что последующие запросы значения будут возвращены немедленно без повторного выполнения кода.
```scheme
;; Сохранение кода в promise с именем sum_promise
scheme@(guile-user)> (define sum_promise (delay (+ 1 2 3 4 5)))

;; Запуск отложенного кода sum_promise
scheme@(guile-user)> (force sum_promise)
$1 = 15
```
[Больше примеров использования ленивых вычислений в языке Scheme](https://www.ibm.com/developerworks/ru/library/l-lazyprog/index.html)


